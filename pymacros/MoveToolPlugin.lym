<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text># --------------------------------------------------------------------------------
# SPDX-FileCopyrightText: 2025 Martin Jan Köhler
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
# SPDX-License-Identifier: GPL-3.0-or-later
#--------------------------------------------------------------------------------

from __future__ import annotations
from dataclasses import dataclass
from functools import cached_property
from typing import *
import os 
import sys

import pya

if sys.version_info &gt;= (3, 11):
    from enum import StrEnum
else:
    from enum import Enum
    class StrEnum(str, Enum):
        def __str__(self) -&gt; str:
            return str(self.value)


DEBUG = False


def debug(*args, **kwargs):
    if DEBUG:
        print(*args, **kwargs)


class MoveQuicklyToolState(StrEnum):
    INACTIVE = "inactive"
    SELECTING = "selecting"               # wait for click to happen to get moving
    DRAG_SELECTING = "drag_selecting"     # user draws a (additional) selection rectangle (shift = additional)
    MOVING = "moving"


@dataclass
class MoveQuicklyToolSelection:
    shapes: List[pya.Shape]
    instances: List[pya.Instance]

    def is_single_selection(self) -&gt; bool:
        return len(self.shapes) + len(self.instances) == 1
        
    def is_multi_selection(self) -&gt; bool:
        return len(self.shapes) + len(self.instances) &gt;= 2
        
    @cached_property
    def bbox(self) -&gt; pya.Box:
        r = pya.Region()
        for s in self.shapes:
            r.insert(s.bbox())
        for i in self.instances:
            r.insert(i.bbox())
        return r.bbox()
        
    @cached_property
    def position(self) -&gt; pya.Point:
        return pya.Point(self.bbox.left, self.bbox.bottom)
        
    def as_transformees(self) -&gt; List[pya.Instance | pya.Shape]:
        return self.shapes + self.instances


@dataclass
class MoveOperation:
    position: pya.DPoint
    delta: pya.DVector


class MoveQuicklyToolSetupDock(pya.QDockWidget):
    def __init__(self, host: MoveQuicklyToolPlugin):
        super().__init__()
        self.setupWidget = MoveQuicklyToolSetupWidget(host)
        self.setWidget(self.setupWidget)
        self.setWindowTitle("Move Quickly Tool")

    def updateState(self, state: MoveQuicklyToolState):
        self.setupWidget.updateState(state)
        
    def updateSelection(self, selection: Optional[MoveQuicklyToolSelection]):
        self.setupWidget.updateSelection(selection)

    def updatePositionValues(self, x: float, y: float, dx: float, dy: float):
        self.setupWidget.updatePositionValues(x, y, dx, dy)

    def navigateToNextTextField(self):
        self.setupWidget.navigateToNextTextField()
        
        
class MoveQuicklyToolSetupWidget(pya.QWidget):
    def __init__(self, host: MoveQuicklyToolPlugin):
        super().__init__()
        self.host = host
        self.selection_label = pya.QLabel('&lt;span style="text-decoration: underline;"&gt;Selection:&lt;/span&gt;')
        self.selection_value = pya.QLabel('None')
        
        self.x_label = pya.QLabel('&lt;span style="text-decoration: underline;"&gt;X:&lt;/span&gt;')
        self.x_value = pya.QDoubleSpinBox()
        self.x_unit = pya.QLabel('µm')
        
        self.y_label = pya.QLabel('&lt;span style="text-decoration: underline;"&gt;Y:&lt;/span&gt;')
        self.y_value = pya.QDoubleSpinBox()
        self.y_unit = pya.QLabel('µm')
        
        self.dx_label = pya.QLabel('&lt;span style="text-decoration: underline;"&gt;dX:&lt;/span&gt;')
        self.dx_value = pya.QDoubleSpinBox()
        self.dx_unit = pya.QLabel('µm')

        self.dy_label = pya.QLabel('&lt;span style="text-decoration: underline;"&gt;dY:&lt;/span&gt;')
        self.dy_value = pya.QDoubleSpinBox()
        self.dy_unit = pya.QLabel('µm')
        
        spin_box_size_policy = pya.QSizePolicy(pya.QSizePolicy.Expanding, pya.QSizePolicy.Expanding)
        for sb in (self.x_value, self.y_value, self.dx_value, self.dy_value):
            sb.setSingleStep(0.01)
            sb.setDecimals(3)
            sb.setMinimum(-float('inf'))
            sb.setMaximum(float('inf'))
            sb.setSizePolicy(spin_box_size_policy)
        
        self.spacerItem = pya.QSpacerItem(0, 20, pya.QSizePolicy.Minimum, pya.QSizePolicy.Fixed)
        self.cancelInfoLabel = pya.QLabel('&lt;span style="color: grey;"&gt;&lt;span style="text-decoration: underline;"&gt;Hint:&lt;/span&gt; Esc to cancel&lt;/span&gt;')
        
        self.layout = pya.QGridLayout()
        self.layout.setSpacing(5)
        self.layout.setVerticalSpacing(5)
        self.layout.addWidget(self.selection_label,     0, 0)
        self.layout.addWidget(self.selection_value,     0, 1)
        self.layout.addWidget(self.x_label,             1, 0)
        self.layout.addWidget(self.x_value,             1, 1)
        self.layout.addWidget(self.x_unit,              1, 2)
        self.layout.addWidget(self.y_label,             2, 0)
        self.layout.addWidget(self.y_value,             2, 1)
        self.layout.addWidget(self.y_unit,              2, 2)
        self.layout.addWidget(self.dx_label,            3, 0)
        self.layout.addWidget(self.dx_value,            3, 1)
        self.layout.addWidget(self.dx_unit,             3, 2)
        self.layout.addWidget(self.dy_label,            4, 0)
        self.layout.addWidget(self.dy_value,            4, 1)
        self.layout.addWidget(self.dy_unit,             4, 2)
        self.layout.addItem(self.spacerItem)
        self.layout.addWidget(self.cancelInfoLabel,     5, 0, 1, 3)
        self.layout.setRowStretch(6, 3)
        self.setLayout(self.layout)
        
    def hideEvent(self, event):
        event.accept()

    def updateState(self, state: MoveQuicklyToolState):
        return

    def format_selection(self, selection: Optional[MoveQuicklyToolSelection]) -&gt; str:
        if selection is None or \
           (len(selection.instances) == 0 and len(selection.shapes) == 0):
            return "None"
        def format_objects(singular: str, objects: List[pya.Shape | pya.Instance]):
            if objects is not None:
                n = len(objects)
                match n:
                    case 0: return ''
                    case 1: return f"1 {singular}"
                    case _: return f"{n} {singular}s"
            return ''
        instances = format_objects("instance", selection.instances)
        shapes = format_objects("shape", selection.shapes)
        if instances == '':
            return shapes
        elif shapes == '':
            return instances
        else:
            return f"{instances}, {shapes}"

    def updateSelection(self, selection: Optional[MoveQuicklyToolSelection]):
        txt = self.format_selection(selection)
        self.selection_value.setText(txt)
        
        enabled = selection is not None
        self.x_value.setEnabled(enabled)
        self.y_value.setEnabled(enabled)
        self.dx_value.setEnabled(enabled)
        self.dy_value.setEnabled(enabled)
        
        if enabled:
            dpos: pya.DPoint = selection.position.to_dtype(self.host.dbu)
            if dpos is None:
                self.x_value.setValue(0.0)
                self.y_value.setValue(0.0)
            else:
                self.x_value.setValue(dpos.x)
                self.y_value.setValue(dpos.y)
        else:
            self.x_value.clearFocus()
            self.y_value.clearFocus()
            self.dx_value.clearFocus()
            self.dy_value.clearFocus()
            
            self.x_value.setValue(0.0)
            self.y_value.setValue(0.0)
        self.dx_value.setValue(0.0)
        self.dy_value.setValue(0.0)

    def updatePositionValues(self, x: float, y: float, dx: float, dy: float):
        self.x_value.setValue(x)
        self.y_value.setValue(y)
        self.dx_value.setValue(dx)
        self.dy_value.setValue(dy)

    def navigateToNextTextField(self):
        self.focusNextPrevChild(next=True)

    def focusNextPrevChild(self, next: bool) -&gt; bool:
        if next:
            if self.x_value.hasFocus():
                self.y_value.setFocus()
                self.y_value.selectAll()
            elif self.y_value.hasFocus():
                self.dx_value.setFocus()
                self.dx_value.selectAll()
            elif self.dx_value.hasFocus():
                self.dy_value.setFocus()
                self.dy_value.selectAll()
            else:
                self.x_value.setFocus()
                self.x_value.selectAll()
        else:
            if self.x_value.hasFocus():
                self.dy_value.setFocus()
                self.dy_value.selectAll()
            elif self.dy_value.hasFocus():
                self.dx_value.setFocus()
                self.dx_value.selectAll()
            elif self.dx_value.hasFocus():
                self.y_value.setFocus()
                self.y_value.selectAll()
            else:
                self.x_value.setFocus()        
                self.x_value.selectAll()
        return True

    def keyPressEvent(self, event: pya.QKeyEvent):
        debug(f"SetupDock.key_event: key={event.key()}, buttons={event.modifiers}")
        match event.key():
            case pya.KeyCode.Enter | pya.KeyCode.Return:
                debug("keyPressEvent: enter!")
                op = MoveOperation(position=pya.DPoint(self.x_value.value, self.y_value.value),
                                   delta=pya.DVector(self.dx_value.value, self.dy_value.value))
                self.host.commit_move(op)
                event.accept()
                return
        super().keyPressEvent(event)
        

class MoveQuicklyToolPlugin(pya.Plugin):
    def __init__(self, view: pya.LayoutView):
        super().__init__()
        self.setupDock      = None
        self.view            = view

        self._state = MoveQuicklyToolState.INACTIVE

        self._selection: Optional[MoveQuicklyToolSelection] = None
        self.move_preview_markers = []
        self.drag_selection_markers = []
        
        self.is_dragging = False
        self.drag_from_dpoint = None
        self.drag_to_dpoint = None

    @property
    def cell_view(self) -&gt; pya.CellView:
        return self.view.active_cellview()

    @property
    def layout(self) -&gt; pya.Layout:
        return self.cell_view.layout()
        
    @property
    def dbu(self) -&gt; float:
        return self.layout.dbu

    @property
    def state(self) -&gt; MoveQuicklyToolState:
        return self._state

    @state.setter
    def state(self, state: MoveQuicklyToolState):
        debug(f"Transitioning from {self._state.value} to {state.value}")
        self._state = state
        if not(self.setupDock):
            pass
        else:
            self.setupDock.updateState(state)
            
    @property
    def selection(self) -&gt; MoveQuicklyToolSelection:
        return self._selection

    @selection.setter
    def selection(self, selection: Optional[MoveQuicklyToolSelection]):
        debug(f"setting selection to {selection}")
        self._selection = selection
        if not(self.setupDock):
            pass
        else:
            self.setupDock.updateSelection(selection)

    def selected_objects(self) -&gt; Optional[MoveQuicklyToolSelection]:
        i = []
        s = []
        for o in self.view.each_object_selected():
            if o.is_cell_inst():
                i += [o.inst()]
            elif o.shape is not None:
                s += [o.shape]
        if not i and not s:
            return None
        return MoveQuicklyToolSelection(instances=i, shapes=s)
        
    def activated(self):
        view_is_visible = self.view.widget().isVisible()
        debug(f"MoveQuicklyToolPlugin.activated, "
              f"for cell view {self.cell_view.cell_name}, "
              f"is visible: {view_is_visible}")
        debug(f"viewport trans: {self.view.viewport_trans()}")
        if not view_is_visible:
            return

        if not(self.setupDock):
            mw   = pya.Application.instance().main_window()
            self.setupDock = MoveQuicklyToolSetupDock(host=self)
            mw.addDockWidget(pya.Qt_DockWidgetArea.RightDockWidgetArea, self.setupDock)
        self.setupDock.show()

        self._state = MoveQuicklyToolState.SELECTING
        self.selection = self.selected_objects()
            
    def deactivated(self):
        debug("MoveQuicklyToolPlugin.deactivated")
        
        self._clear_all_markers()
        self.selection = None
        self.is_dragging = False

        self._state = MoveQuicklyToolState.INACTIVE
        
        self.ungrab_mouse()
        if self.setupDock:
            self.setupDock.hide()

    def deactivate(self):
        debug("MoveQuicklyToolPlugin.deactivate")
        esc_key  = 16777216 
        keyPress = pya.QKeyEvent(pya.QKeyEvent.KeyPress, esc_key, pya.Qt.NoModifier)
        pya.QApplication.sendEvent(self.view.widget(), keyPress)        

    def _clear_move_preview_markers(self):
        for marker in self.move_preview_markers:
            marker._destroy()
        self.move_preview_markers = []
        
    def _clear_drag_selection_markers(self):
        for marker in self.drag_selection_markers:
            marker._destroy()
        self.drag_selection_markers = []

    def _clear_all_markers(self):
        self._clear_move_preview_markers()
        self._clear_drag_selection_markers()
        
    def update_preview_markers(self):
        self._clear_move_preview_markers()
        
        if self.selection is None:
            return
        
        match self.state:
            case MoveQuicklyToolState.INACTIVE | MoveQuicklyToolState.SELECTING | MoveQuicklyToolState.DRAG_SELECTING:
                return
            case MoveQuicklyToolState.MOVING:
                delta = self.move_to_dpoint - self.move_from_dpoint                                                
                preview_box = self.selection.bbox.to_dtype(self.dbu).moved(delta)
                
                marker = pya.Marker(self.view)
                marker.line_style     = 0
                marker.line_width     = 2
                marker.vertex_size    = 0 
                marker.dither_pattern = 1
                marker.set(preview_box)
                self.move_preview_markers += [marker]
        
    def update_drag_selection_markers(self):
        self._clear_drag_selection_markers()
        
        match self.state:
            case MoveQuicklyToolState.INACTIVE | MoveQuicklyToolState.SELECTING | MoveQuicklyToolState.MOVING:
                return
            case MoveQuicklyToolState.DRAG_SELECTING:
                selection_box = pya.DBox(self.drag_selection_from_dpoint, self.drag_selection_to_dpoint)

                marker = pya.Marker(self.view)
                marker.line_style     = 2
                marker.line_width     = 2
                marker.vertex_size    = 0 
                marker.dither_pattern = 1
                marker.set(selection_box)
                self.drag_selection_markers += [marker]
        
    def select_object_at(self, dpoint: pya.DPoint, buttons: int):
        if buttons &amp; pya.ButtonState.ShiftKey:
            selection_mode = pya.LayoutView.SelectionMode.Add
        else:
            selection_mode = pya.LayoutView.SelectionMode.Replace
        self.view.select_from(dpoint, selection_mode)
        self.selection = self.selected_objects()
       
    def visible_layer_indexes(self) -&gt; List[int]:
        idxs = []
        for lref in self.view.each_layer():
            if lref.visible and lref.valid:
                if lref.layer_index() == -1:  # hidden by the user
                    continue
                # print(f"layer is visible, name={lref.name}, idx={lref.layer_index()}, "
                #       f"marked={lref.marked} cellview={lref.cellview()}, "
                #      f"source={lref.source}")
                idxs.append(lref.layer_index())
        return idxs
    
    def select_objects(self, search_box: pya.DBox, selection_mode: pya.LayoutView.SelectionMode):
        search_box = search_box.to_itype(self.dbu)
        visible_layer_indexes = self.visible_layer_indexes()
        for top_cell in self.layout.top_cells():
            if self.cell_view.is_cell_hidden(top_cell):
                continue
            if self.view.max_hier_levels &gt;= 1:
                iter = top_cell.begin_instances_rec_overlapping(search_box)
                iter.min_depth = max(self.view.min_hier_levels-1, 0)
                iter.max_depth = max(self.view.max_hier_levels-1, 0)
                while not iter.at_end():
                    inst = iter.current_inst_element().inst()
                    hidden = self.view.is_cell_hidden(inst.cell.cell_index(), self.view.active_cellview_index)
                    if not hidden:
                        self.view.select_from(inst.bbox().to_dtype(self.dbu), selection_mode)
                    iter.next()
            if self.view.max_hier_levels &gt;= 1:
                for lyr in visible_layer_indexes:
                    iter = top_cell.begin_shapes_rec_overlapping(lyr, search_box)
                    iter.min_depth = max(self.view.min_hier_levels-1, 0)
                    iter.max_depth = max(self.view.max_hier_levels-1, 0)
                    while not iter.at_end():
                        sh = iter.shape()
                        self.view.select_from(sh.bbox().to_dtype(self.dbu), selection_mode)
                        iter.next()
        
    def mouse_moved_event(self, dpoint: pya.DPoint, buttons: int, prio: bool):
        if prio:
            # print(f"mouse moved event, p={dpoint}, buttons={buttons}, prio={prio}")
            
            # NOTE: dragging will change the selection
            #       clicking (select object) and moving without dragging will show the move preview
            
            if buttons &amp; pya.ButtonState.LeftButton:  # drag selection
                match self.state:
                    case MoveQuicklyToolState.INACTIVE | MoveQuicklyToolState.SELECTING | MoveQuicklyToolState.MOVING:
                        self.state = MoveQuicklyToolState.DRAG_SELECTING
                        # NOTE: the from point is directly recorded via mouse_button_pressed_event, because some drag events could be skipped!
                        self.drag_selection_to_dpoint = dpoint
                    case MoveQuicklyToolState.DRAG_SELECTING:
                        self.drag_selection_to_dpoint = dpoint
                
                self.select_objects(pya.DBox(self.drag_selection_from_dpoint, self.drag_selection_to_dpoint), pya.LayoutView.SelectionMode.Add)
                self.selection = self.selected_objects()
                
                self.update_drag_selection_markers()
                return True
            elif buttons &amp; pya.ButtonState.ShiftKey:
                state = MoveQuicklyToolState.SELECTING
                self._clear_move_preview_markers()
                return True
            else:
                # print(f"mouse drag event, p={dpoint}, buttons={buttons}, prio={prio}")
                if self.state == MoveQuicklyToolState.MOVING:
                    self.move_to_dpoint = dpoint
                    
                    self.update_preview_markers()
                    orig_pos = self.selection.position.to_dtype(self.dbu)
                    delta = self.move_to_dpoint - self.move_from_dpoint
                    self.setupDock.updatePositionValues(orig_pos.x + delta.x,
                                                        orig_pos.y + delta.y,
                                                        delta.x, delta.y)
                    return True
        return False

    def mouse_button_pressed_event(self, dpoint: pya.DPoint, buttons: int, prio: bool) -&gt; bool:
        # NOTE: directly record drag selection origin, because some drag events could be skipped!
        self.drag_selection_from_dpoint = dpoint
        return False

    def mouse_button_released_event(self, dpoint: pya.DPoint, buttons: int, prio: bool) -&gt; bool:
        # print(f"mouse button released event, p={dpoint}, buttons={buttons}, prio={prio}")
        
        if self.is_dragging:
            self.is_dragging = False
            self.drag_from_dpoint = None
            self.drag_to_dpoint = None
            return True

        match self.state:
            case MoveQuicklyToolState.INACTIVE:
                pass
            case MoveQuicklyToolState.SELECTING:
                if self.selection is not None and not buttons &amp; pya.ButtonState.ShiftKey:
                    self.state = MoveQuicklyToolState.MOVING
                    self.move_from_dpoint = dpoint
                    return True                        
            case MoveQuicklyToolState.DRAG_SELECTING:
                self._clear_drag_selection_markers()
                self.drag_selection_from_dpoint = None
                self.drag_selection_to_dpoint = None
                self.state = MoveQuicklyToolState.SELECTING
                return True
                
            case MoveQuicklyToolState.MOVING:
                pass
                
        return False

    def mouse_click_event(self, dpoint: pya.DPoint, buttons: int, prio: bool) -&gt; bool:
        if prio:
            if buttons &amp; pya.ButtonState.LeftButton:
                match self.state:
                    case MoveQuicklyToolState.INACTIVE:
                        pass
                    case MoveQuicklyToolState.SELECTING:
                        if self.selection is None or buttons &amp; pya.ButtonState.ShiftKey:
                            self._clear_all_markers()
                            self.select_object_at(dpoint, buttons)
                            
                        if self.selection is not None and not buttons &amp; pya.ButtonState.ShiftKey:
                            self.state = MoveQuicklyToolState.MOVING
                            self.move_from_dpoint = dpoint
                        return True                        
                    case MoveQuicklyToolState.DRAG_SELECTING:
                        pass
                    case MoveQuicklyToolState.MOVING:
                        if buttons &amp; pya.ButtonState.ShiftKey:
                            self.select_object_at(dpoint, buttons)
                            self._clear_all_markers()
                            self.state = MoveQuicklyToolState.SELECTING
                        elif self.selection is not None:
                            delta = self.move_to_dpoint - self.move_from_dpoint
                            origin_pos = self.selection.position.to_dtype(self.dbu)
                            self.commit_move(MoveOperation(position=origin_pos, delta=delta))
                        return True                        
            elif buttons in [pya.ButtonState.RightButton, pya.ButtonState.RightButton]:
                self._clear_all_markers()
                self.view.clear_selection()
                self.selection = None
                self.state = MoveQuicklyToolState.SELECTING
                return True
                
        return False
        
    def key_event(self, key: int, buttons: int):
        # debug(f"key_event: key={key}, buttons={buttons}")
        
        if buttons &amp; pya.ButtonState.ShiftKey and \
           self.state == MoveQuicklyToolState.MOVING:
            debug("key_event: shift cancels moving!")
            self.state = MoveQuicklyToolState.SELECTING
            self._clear_move_preview_markers()
            return True
                
        match key:
            case pya.KeyCode.Tab:
                # debug("key_event: tab!")
                if self.selection is not None:
                    orig_pos = self.selection.position.to_dtype(self.dbu)
                    self.setupDock.updatePositionValues(orig_pos.x,
                                                        orig_pos.y,
                                                        0.0, 0.0)
                    self._clear_move_preview_markers()
                    self.setupDock.navigateToNextTextField()
                    return True
                
            case pya.KeyCode.Enter | pya.KeyCode.Return:
                # debug("key_event: enter!")
                if self.selection is not None:
                    self.commit_move()
                    return True
                    
        return False
        
    def commit_move(self, operation: MoveOperation):
        self._clear_all_markers()
        self.view.clear_selection()
        if self.selection is None:
            self.state = MoveQuicklyToolState.SELECTING
            return
            
        origin_pos = self.selection.position.to_dtype(self.dbu)
        dx = operation.position.x + operation.delta.x - origin_pos.x
        dy = operation.position.y + operation.delta.y - origin_pos.y

        debug(f"commit_move: origin_pos={origin_pos}, self.selection.position={self.selection.position}, "
              f"operation.position={operation.position}, operation.delta={operation.delta}")
            
        self.view.transaction("move quickly")
        try:
            trans = pya.DTrans(dx, dy)
            for t in self.selection.as_transformees():
                t.transform(trans)
        finally:
            self.view.commit()
            self.view.clear_selection()
            self.selection = None
            # NOTE: do not deactivate, stay in M-mode!
            self.state = MoveQuicklyToolState.SELECTING


class MoveQuicklyToolPluginFactory(pya.PluginFactory):
    def __init__(self):
        super().__init__()
        iconPath = os.path.join(os.path.dirname(__file__), 'MoveToolIcon', '%s.png')
        self.register(-1000, "Move Quickly Tool", "Move Quickly", iconPath % "icon")
  
    def create_plugin(self, manager, root, view):
        return MoveQuicklyToolPlugin(view)

MoveQuicklyToolPluginFactory.instance = MoveQuicklyToolPluginFactory()
</text>
</klayout-macro>
